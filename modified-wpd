#!/usr/bin/env python
'''
This file is a copy of "wpd" from https://github.com/borismus/webplatform-tools.

Small modifications were made so that this can be run in batch, namely:
* Read wiki username/password from environment variables
* Read wiki root url from environment variable
* Read page contents from a file
'''

import os
from optparse import OptionParser
from httplib import HTTPConnection
import urllib, urllib2
import json
import sys
import getpass

#
# Read from env vars wiki username/password and root URL where the api.php lives.
#
DEFAULT_USERNAME = os.getenv ("WPD_USERNAME")
DEFAULT_PASSWORD = os.getenv ("WPD_PASSWORD")
API_ROOT = os.getenv ("WPD_API_ROOT") + "/api.php?"
# API_ROOT = 'http://docs.webplatform.org/w/api.php?'
DEFAULT_PARAMS = {'format': 'json'}

# Usage for this program
usage = """
Usage:    modified-wpd command <arguments>
Commands:
    ls <prefix>
        Lists file beginning with optional prefix

    edit <page> <filename>
        Replaces the content of the specified page, using the file contents

Environment variables:
    WPD_USERNAME - username to login to wiki
    WPD_PASSWORD - password to login to wiki
    WPD_API_ROOT - root url of wiki api (do not include /api.php at end)
"""

parser = OptionParser(usage=usage)
parser.add_option('-u', '--username')


class WPDConnection:

  def __init__(self, name=None):
    self.name = name

    cookie_handler = urllib2.HTTPCookieProcessor()
    redirect_handler = urllib2.HTTPRedirectHandler()
    self.opener = urllib2.build_opener(redirect_handler, cookie_handler)

  def logout(self):
    '''Logout from wiki, assumption is that this always succeeds.'''
    params = {
      'action': 'logout',
    }
    params.update(DEFAULT_PARAMS)
    resp = json.loads(self.opener.open(API_ROOT, urllib.urlencode(params)).read())

  def login(self):
    '''
    Login to wiki.

    The side effect is that a cookie gets set used on subsequent requests to
    validate logged-in user.
    '''
    password = DEFAULT_PASSWORD or getpass.getpass()
    params = {
      'action': 'login',
      'lgname': self.name,
      'lgpassword': password
    }
    params.update(DEFAULT_PARAMS)

    # Issue an initial login request
    resp = json.loads(self.opener.open(API_ROOT, urllib.urlencode(params)).read())

    # See if there was an error
    if ('error' in resp):
        if ('info' in resp['error']):
            raise Exception, 'Error logging in:\n{}'.format (resp['error']['info'])
        else:
            raise Exception, 'Unknown error logging in:\n{}'.format (resp['error'])

    # See if there was a login response
    if ('login' in resp):
        if ('result' in resp['login']):
            if (resp['login']['result'] == 'NeedToken' and 'token' in resp['login']):
                # Now use the response token to do another login request
                params['lgtoken'] = resp['login']['token']
                resp = json.loads(self.opener.open(API_ROOT, urllib.urlencode(params)).read())
        else:
            raise Exception, 'Unknown login results:\n{}'.format (resp['login'])
    else:
        # Missing login section of response
        raise Exception, 'Unknown response:\n{}'.format (resp)

    # See if the last response was a success
    if ('login' in resp and 'result' in resp['login'] and resp['login']['result'] == 'Success' and 'lgtoken' in resp['login']):
        self.is_logged_in = True
    else:
        raise Exception, 'Failed to login:\n{}'.format (resp)

  def ls(self, prefix='', offset=0, limit=20):
    '''
    Lists all pages under the specified prefix.

    If no prefix is specified, lists all pages.
    '''
    if not prefix:
      prefix = ''

    params = {
        'action': 'query',
        'list': 'allpages',
        'apprefix': prefix,
        'aplimit': limit + 1
    }
    params.update(DEFAULT_PARAMS)
    resp = json.loads(self.opener.open(API_ROOT, urllib.urlencode(params)).read())
    if ('query' in resp and 'allpages' in resp['query']):
      page_json = resp['query']['allpages']
      page_list = [p['title'] for p in page_json]
      return page_list
    else:
      raise Exception, 'Unknown list response:\n{}'.format (resp)

  def get_edit_token(self, page):
    '''
    In order to edit a specific page, obtain an edit token.

    Called from edit, so no need to call this manually.
    '''
    params = {
        'action': 'query',
        'prop': 'info',
        'intoken': 'edit',
        'titles': page
    }
    params.update(DEFAULT_PARAMS)
    # print ("GET EDIT TOKEN REQUEST:\n{}".format (params))
    url = API_ROOT + urllib.urlencode(params)
    resp = json.loads(self.opener.open(url).read())
    # print ("GET EDIT TOKEN RESPONSE:\n{}".format (resp))

    # See if there was an error
    if ('error' in resp):
        if ('info' in resp['error']):
            raise Exception, 'Error getting edit token:\n{}'.format (resp['error']['info'])
        else:
            raise Exception, 'Unknown error getting edit token:\n{}'.format (resp['error'])

    # Get the revision number 4747
    if ('query' in resp and 'pages' in resp['query'] and len (resp['query']['pages']) == 1):
      pages = resp['query']['pages']
      page = pages[pages.keys()[0]]
      # Return edit token for that revision number
      return page['edittoken']
    else:
      raise Exception, 'Unknown response getting edit token:\n{}'.format (resp)

  def edit(self, page, content, edit_summary, section=None):
    '''
    Replaces the content for the particular page.
    '''
    if not self.is_logged_in:
      raise Exception, 'User %s is not logged in.' %self.name
    edittoken = self.get_edit_token(page)
    params = {
        'action': 'edit',
        'title': page,
        'summary': edit_summary,
        'text': content,
        'bot': '1',
        'watchlist': 'nochange',
        'token': edittoken
    }
    params.update(DEFAULT_PARAMS)
    # print ("EDIT REQUEST:\n{}".format (params))
    resp = json.loads(self.opener.open(API_ROOT, urllib.urlencode(params)).read())
    # print ("EDIT RESPONSE:\n{}".format (resp))

    # See if there was an error
    if ('error' in resp):
        if ('info' in resp['error']):
            raise Exception, 'Error editing page:\n{}'.format (resp['error']['info'])
        else:
            raise Exception, 'Unknown error editing page:\n{}'.format (resp['error'])

    if ('edit' in resp and 'result' in resp['edit'] and resp['edit']['result'] == 'Success'):
      print "Success"
    else:
      raise Exception ("Edit not successful:\n{}".format (resp))

if __name__ == '__main__':
  (options, args) = parser.parse_args()
  if len(args) == 0:
    print usage
    sys.exit(1)

  command = args[0]
  username = options.username or DEFAULT_USERNAME
  conn = WPDConnection(username)

  if command == 'ls':
    prefix = (len(args) == 2 and args[1])
    print '\n'.join(conn.ls(prefix))

  if command == 'edit':
    if len(args) != 4:
      print 'wpd edit <page> <filename> <editsummary>'
      sys.exit(1)
    page = args[1]
    content = open (args[2], 'r').read ()
    edit_summary = args[3]
    conn.login()
    conn.edit(page, content, edit_summary)
    conn.logout()
